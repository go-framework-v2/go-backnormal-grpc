# 架构设计文档

包含项目目录结构，以及从0到1的设计思路和框架搭建。

## 目录结构初始化

- 新建文件夹以及对应文件夹下需要的文件。
- 在项目根目录下，进行go.work的工作区初始化，用于管理多模块开发还款中的工作区。通过工作区，开发者可以同时引用和修改多个模块，而无需将它们安装到$GOPATH或手动管理版本。这极大地提升了多模块开发的效率和便捷性。

```
1. 初始化一个工作区并生成一个go.work文件。该文件描述了工作区的配置，包括包含的模块路径等。
go work init

2. 管理模块
添加模块：通过go work use命令可以将新的模块添加到工作区中。
移除模块：使用go work use-drop或go work edit-dropuse命令可以从工作区中移除指定的模块。
列出模块：使用go work edit命令可以查看和编辑工作区中包含的模块列表。

3. 启用工作区
在工作区模式下运行Go工具链（如go build、go test、go run等）时，Go会自动识别并使用go.work文件中描述的模块。
```

- 在src所在终端，进行moudle的模块初始化，以及在src/cmd目录下创建main.go文件。

```
go mod init github.com/huanlema/go-backnormal
```

```
package main

func main() {
    fmt.Println("Hello, world!")
}
```

## 目录结构初始化-v2

将整个项目视作一个模块，不使用go.work工作区。

目录分层遵循按功能模块分，即一个目录完成一个模块的功能。

```
  
-main.go  // 项目启动文件
-go.mod
-go.sum
-doc  // 文档目录
-src  // 源码目录
  -access  // 全局输入输出处理
    -common.go  // 通用结构体定义
    -paraIn.go  // 输入结构体定义和相关方法
    -paraOut.go  // 输出结构体定义和相关方法
  -api  // controller层，全局API注册
    -router.go  // 提供所有路由方法注册初始化函数
    -routerXX.go  // 路由分组，需要在router.go中注册
  -conf  // 配置文件目录
    -config.go  // 全局配置文件config.yaml对应结构体和初始化函数，以及提供全局配置文件访问对象
    -xxConfig.go  // 分离的子配置结构体
    -config.yaml  // 全局配置文件
  -const  // 常量目录，存放全局初始化操作之类的常量
    -res.go  // 比如，初始化资源对象需要用的常量
  -res  // 全局资源对象目录，提供初始化方法。和暴露的全局单例资源对象
  -log  // 全局日志相关初始化函数和对象
  -test  // 测试目录
  -internal  // 业务源码目录
    -demo1  // 功能模块1
      -dao  
        -po  // 数据库实体结构体目录
        -xxDao.go  // po目录下对应的实体具体实现dao层
      -model
        -dto  // 视图层的数据传输对象结构体定义
        -bo  // 业务层的数据层传输对象的结构体定义
      -service
        -xxService.go  // 复杂的处理函数
      -rest.go  // gin handler函数
    -demo2  // 功能模块2
```

## 全局资源对象：使用工厂+注册机制实现

对于数据库连接、其他需要操作的客户端：比如Redis客户端、阿里云oss客户端等等，这种全局且唯一的对象，且需要根据业务场景不断加入这种插件式架构，适合使用该设计模式。

具体实现代码如下：

resource/resource.go：定义资源接口。

db/dbResource.go， client/ossResource.go：具体实现资源结构体，对外暴露全局统一访问点，如MySQL数据库连接对象，oss客户端对象，具体Bucket对象等等。

global/initResource.go：可在每个包的init函数中自动注册，也可手动注册，推荐手动注册。

cmd/main.go：注册资源对象，并打印日志信息。

main.go：在可执行文件中，调用注册方法。

## 判空封装：简化校验步骤

一般情况，对于请求body携带的各个参数，需要做一些空值判断。一个一个进行判断和错误处理，简单代码量太多。可以对类型空值进行操作，然后得到bool值进行判断。

启发：(布尔类型)[https://c.biancheng.net/view/17.html]

```
// itob 用于判断一个变量是否为真值（非 nil、非零值）后续待完善
func itob(i interface{}) bool {
	if i == nil {
		return false
	}

	// 先尝试类型断言（快速路径）
	switch v := i.(type) {
	case bool:
		return v
	case int, int8, int16, int32, int64:
		return reflect.ValueOf(i).Int() != 0
	case uint, uint8, uint16, uint32, uint64, uintptr:
		return reflect.ValueOf(i).Uint() != 0
	case float32, float64:
		return reflect.ValueOf(i).Float() != 0
	case string:
		return v != ""
	case []byte:
		return len(v) > 0
	}

	// 其他类型使用反射
	val := reflect.ValueOf(i)
	switch val.Kind() {
	case reflect.Ptr, reflect.Func, reflect.Chan, reflect.Map:
		return !val.IsNil()
	case reflect.Array, reflect.Slice:
		return val.Len() > 0
	case reflect.Struct:
		return !val.IsZero()
	default:
		return true
	}
}
```

## 日志输出和文件切割：zap+lumberback

...

需要再main.go文件启动时，调用初始化函数。

## 配置文件读取(简化版)：viper

...

需要再main.go文件启动时，调用初始化函数。

## 数据访问对象(dao)实现：dao目录代码示例

...

## 完整流程使用示例

...
